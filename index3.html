import { useMemo, useState } from "react";

export default function App() {
   // Data + errors
   const [data, setData] = useState<any[]>([]);
   const [error, setError] = useState("");

   // Controls
   const [minSigned, setMinSigned] = useState(-2);
   const [maxSigned, setMaxSigned] = useState(3);
   const [direction, setDirection] = useState<"ALL" | "Long" |
"Inverse">("ALL");
   const [issuer, setIssuer] = useState<string>("ALL");
   const [underlying, setUnderlying] = useState<string>("ALL");
   const [q, setQ] = useState("");
   const [sortKey, setSortKey] = useState<string>("assets");
   const [sortDir, setSortDir] = useState<"asc" | "desc">("desc");

   async function handleUpload(e: React.ChangeEvent<HTMLInputElement>) {
     const file = e.target.files?.[0];
     if (!file) return;
     try {
       const text = await file.text();
       const json = JSON.parse(text);
       setData(Array.isArray(json) ? json : []);
       setError("");
     } catch (err: any) {
       setError("Invalid JSON file: " + (err?.message ?? String(err)));
     }
   }

   // Allowed/visible issuers
   const ALLOWED_ISSUERS = [
     "Direxion",
     "GraniteShares",
     "T-Rex",
     "Tradr",
     "Leverage Shares",
     "Defiance",
   ];

   function detectIssuer(name: string = "", fundType: string = ""): string {
     const hay = (name + " " + fundType).toLowerCase();
     for (const ix of ALLOWED_ISSUERS) {
       if (hay.includes(ix.toLowerCase())) return ix;
     }
     return "Other";
   }

   // Known tickers & name→ticker map (expand as needed)
   const TICKER_GUESS = [
"AAPL","TSLA","NVDA","AMD","MSFT","META","AMZN","GOOGL","GOOG","NFLX",
"NIO","BABA","SHOP","COIN","UBER","IBM","INTC","T","V","MA","JPM","BAC",
"WMT","DIS","PYPL","PFE","XOM","CVX","NKE","SQ","PLTR","SOFI","SNAP","CRM",
     "ORCL","BA","ABBV","ADI","MU","PANW","ASML","AVGO"
   ];
   const NAME_TO_TICKER: Record<string, string> = {
     "tesla":"TSLA","apple":"AAPL","nvidia":"NVDA","advanced micro
devices":"AMD","amd":"AMD",
"microsoft":"MSFT","meta":"META","facebook":"META","amazon":"AMZN","alphabet":"GOOGL","google":"GOOGL",
"netflix":"NFLX","nio":"NIO","alibaba":"BABA","shopify":"SHOP","coinbase":"COIN","uber":"UBER","ibm":"IBM",
"intel":"INTC","at&t":"T","visa":"V","mastercard":"MA","jpmorgan":"JPM","bank
of america":"BAC","walmart":"WMT",
"disney":"DIS","paypal":"PYPL","pfizer":"PFE","exxon":"XOM","chevron":"CVX","nike":"NKE","block":"SQ",
"palantir":"PLTR","sofi":"SOFI","snap":"SNAP","salesforce":"CRM","oracle":"ORCL","boeing":"BA",
     "abbvie":"ABBV","analog devices":"ADI","micron":"MU","palo alto
networks":"PANW","asml":"ASML","broadcom":"AVGO"
   };

   // Robust underlying detection (cleans T-Rex brand noise)
   function detectUnderlying(r: any): string {
     const explicit =
       r["Underlying"] ||
       r["Underlying Asset"] ||
       r["Reference Asset"] ||
       r["Underlying Ticker"] ||
       r["Underlying Symbol"] ||
       r["Underlying Equity"];
     if (typeof explicit === "string" && explicit.trim()) {
       return explicit.trim().toUpperCase();
     }

     const name = String(r["Name"] ?? "");
     const ft   = String(r["Fund Type"] ?? "");
     const seg  = String(r["segment"] ?? "");
     const hay  = `${name} ${ft} ${seg}`;

     // Clean out brand tokens that confuse parsing (avoid returning "T"
or "REX")
     const hayClean = hay
       .replace(/\bT[-\s]?REX\b/gi, " ")
       .replace(/\bREX\b/gi, " ")
       .replace(/\bT\b(?=\s*-\s*REX\b)/gi, " ");

     // (a) Parenthetical/separators: require trailing delimiter
     const sep =
hayClean.match(/[\(\[\-–—:\/]\s*([A-Z]{2,5})(?=[\)\]\s:\/\-])/);
     if (sep && sep[1]) return sep[1].toUpperCase();

     // (b) Verbs
     const verbTok = hayClean.match(/\b(on|tracking|linked to|based
on|over|vs\.?|for)\s+([A-Z]{2,5})\b/i);
     if (verbTok && verbTok[2]) return verbTok[2].toUpperCase();

     // (b2) After direction words
     const afterDir =
hayClean.match(/\b(Long|Short|Bull|Bear)\s+([A-Z]{2,5})\b/i);
     if (afterDir && afterDir[2]) return afterDir[2].toUpperCase();

     // (c) Known tickers: skip 'T' unless AT&T is explicit
     for (const sym of TICKER_GUESS) {
       if (sym === "T") {
         if (/\bAT&T\b/i.test(hayClean)) return "T";
         continue;
       }
       if (new RegExp(`\\b${sym}\\b`, "i").test(hayClean)) return sym;
     }

     // (d) Company name → ticker
     const lower = hayClean.toLowerCase();
     for (const [k, v] of Object.entries(NAME_TO_TICKER)) {
       if (lower.includes(k)) return v;
     }

     // (e) Right before classification words
     const nearClass =
hayClean.match(/\b([A-Z]{2,5})\b\s+(?:Daily|Target|Bull|Bear|ETF|Shares)/);
     if (nearClass && nearClass[1] &&
!/(?:^|\s)(?:T|REX)(?:\s|$)/i.test(nearClass[1])) {
       return nearClass[1].toUpperCase();
     }

     // (f) Last resort: uppercase token not in STOP, length >= 2
     const STOP = new Set([
"ETF","ETFS","BULL","BEAR","ULTRA","ULTRAPRO","ULTRASHORT","DAILY","SHARES","LEVERAGED",
"LONG","SHORT","INVERSE","PROSHARES","DIREXION","GRANITESHARES","T-REX","TRADR","LEVERAGE",
"DEFIANCE","SINGLE","STOCK","US","ON","OF","FOR","AND","VS","INDEX","TRACKING","LINKED","TO","X",
       "REX","T"
     ]);
     const candidates = (hayClean.match(/\b[A-Z]{1,5}\b/g) || [])
       .map(t => t.toUpperCase())
       .filter(t => t.length >= 2 && !STOP.has(t));
     if (candidates.length) return candidates[0];

     return "Unknown";
   }

   // Normalize rows
   const rows = useMemo(() => {
     return (data || [])
       // single-stock universe only
       .filter((r) => {
         const seg = String(r.segment ?? "");
         const ft  = String(r["Fund Type"] ?? "");
         const nm  = String(r["Name"] ?? "");
         return /single/i.test(seg) || /single\s*-?\s*stock/i.test(ft)
|| /single\s*-?\s*stock/i.test(nm);
       })
       .map((r) => {
         const name = String(r["Name"] ?? "");
         const ft   = String(r["Fund Type"] ?? "");
         const hay  = name + " " + ft;

         // Direction
         let dir: "Long" | "Inverse" | null = null;
         if (/(bear|short|inverse|ultrashort)/i.test(hay)) dir = "Inverse";
         else if (/(bull|long|ultra|ultrapro)/i.test(hay)) dir = "Long";

         // Leverage magnitude (unsigned)
         let lev: number | null = null;
         const m = hay.match(/(\d+(?:\.\d+)?)x/i);
         if (m) lev = Number(m[1]);
         else if (/ultrapro/i.test(hay)) lev = 3;
         else if (/ultrashort/i.test(hay)) lev = 2;
         else if (/\bultra\b/i.test(hay)) lev = 2;

         // Signed leverage
         const signedLev = lev == null ? null : (dir === "Inverse" ?
-Math.abs(lev) : Math.abs(lev));

         // Issuer, underlying, URL
         const issuerDetected = detectIssuer(name, ft);
         const underlyingDetected = detectUnderlying(r);
         const url = r["URL"] || r["Url"] || r["url"] || null;

         // Clean ticker (remove trailing "US")
         let cleanTicker = r["Ticker"];
         if (typeof cleanTicker === "string") cleanTicker =
cleanTicker.replace(/US$/i, "");

         return {
           ...r,
           Ticker: cleanTicker,
           issuerDetected,
           underlyingDetected,
           direction: dir,
           leverage: lev,
           signedLev,
           url,
         };
       });
   }, [data]);

   // Slider bounds from data
   const maxAbs = Math.max(1, ...rows.map((r) => Math.abs(r.signedLev ??
0)));
   const sliderMin = -maxAbs;
   const sliderMax = maxAbs;

   // Dropdown lists
   const issuers = useMemo(() => {
     const present = new Set(rows.map((r) =>
r.issuerDetected).filter((ix) => ALLOWED_ISSUERS.includes(ix)));
     return ["ALL", ...ALLOWED_ISSUERS.filter((ix) => present.has(ix))];
   }, [rows]);

   const underlyings = useMemo(() => {
     const set = new Set<string>();
     rows.forEach((r) => set.add(String(r.underlyingDetected ??
"Unknown")));
     const arr = Array.from(set).sort((a, b) => a.localeCompare(b));
     return ["ALL", ...arr];
   }, [rows]);

   // Filter + search + sort
   const filtered = useMemo(() => {
     const base = rows.filter((r) => {
       if (issuer !== "ALL" && r.issuerDetected !== issuer) return false;
       if (direction !== "ALL" && (r.direction ?? "—") !== direction)
return false;
       if (underlying !== "ALL" && String(r.underlyingDetected ??
"Unknown") !== underlying) return false;
       if (r.signedLev != null) {
         const lo = Math.min(minSigned, maxSigned);
         const hi = Math.max(minSigned, maxSigned);
         if (r.signedLev < lo || r.signedLev > hi) return false;
       }
       return true;
     });

     const qnorm = q.trim().toLowerCase();
     const qfiltered = qnorm
       ? base.filter((r) => (
           String(r["Ticker"]).toLowerCase().includes(qnorm) ||
           String(r["Name"]).toLowerCase().includes(qnorm) ||
           String(r.issuerDetected).toLowerCase().includes(qnorm) ||
           String(r.underlyingDetected).toLowerCase().includes(qnorm)
         ))
       : base;

     const sorted = [...qfiltered].sort((a, b) => {
       const dir = sortDir === "asc" ? 1 : -1;
       const num = (x: any) => (typeof x === "number" ? x :
Number(String(x).replace(/[^0-9.\-]/g, "")) || 0);
       switch (sortKey) {
         case "ticker":
           return dir *
String(a["Ticker"]).localeCompare(String(b["Ticker"]));
         case "name":
           return dir * String(a["Name"]).localeCompare(String(b["Name"]));
         case "issuer":
           return dir *
String(a.issuerDetected).localeCompare(String(b.issuerDetected));
         case "underlying":
           return dir *
String(a.underlyingDetected).localeCompare(String(b.underlyingDetected));
         case "lev":
           return dir * ((a.signedLev ?? 0) - (b.signedLev ?? 0));
         case "fee":
           return dir * (num(a["Expense Ratio"]) - num(b["Expense Ratio"]));
         case "assets":
         default:
           return dir * (num(a["Fund Assets (M USD)"]) - num(b["Fund
Assets (M USD)"]));
       }
     });

     return sorted;
   }, [rows, issuer, direction, underlying, minSigned, maxSigned, q,
sortKey, sortDir]);

   // Empty state
   if (data.length === 0) {
     return (
       <div className="min-h-screen bg-gradient-to-b from-zinc-50
to-white text-zinc-900">
         <header className="sticky top-0 z-20 backdrop-blur bg-white/70
border-b">
           <div className="mx-auto max-w-7xl px-4 py-4 flex items-center
gap-3">
             <div className="h-9 w-9 rounded-xl bg-black text-white grid
place-items-center font-bold">LE</div>
             <h1 className="text-xl font-semibold
tracking-tight">Leveraged Single-Stock ETF Catalog</h1>
           </div>
         </header>
         <main className="mx-auto max-w-7xl px-4 py-8 grid gap-6">
           <div className="rounded-2xl border bg-white p-6 shadow-sm">
             <p className="text-sm text-zinc-600 mb-3">Upload your
generated JSON to get started.</p>
             <input type="file" accept="application/json"
onChange={handleUpload} className="block w-full rounded-xl border
border-zinc-300 p-3 text-sm" />
             {error && <div className="mt-3 text-sm
text-red-600">{error}</div>}
           </div>
           <div className="grid sm:grid-cols-3 gap-4">
             <div className="rounded-2xl border bg-white p-4">
               <div className="text-xs uppercase tracking-wide
text-zinc-500">Universe</div>
               <div className="mt-1 text-2xl font-semibold">Single-Stock
ETFs</div>
             </div>
             <div className="rounded-2xl border bg-white p-4">
               <div className="text-xs uppercase tracking-wide
text-zinc-500">Leverage</div>
               <div className="mt-1 text-2xl font-semibold">-3x to +3x</div>
             </div>
             <div className="rounded-2xl border bg-white p-4">
               <div className="text-xs uppercase tracking-wide
text-zinc-500">Issuers</div>
               <div className="mt-1 text-2xl font-semibold">Direxion •
GraniteShares • T-Rex • Tradr • Leverage Shares • Defiance</div>
             </div>
           </div>
         </main>
       </div>
     );
   }

   // Main UI
   return (
     <div className="min-h-screen bg-gradient-to-b from-zinc-50 to-white
text-zinc-900">
       {/* Top bar */}
       <header className="sticky top-0 z-20 backdrop-blur bg-white/70
border-b">
         <div className="mx-auto max-w-7xl px-4 py-4 flex items-center
gap-3">
           <div className="h-9 w-9 rounded-xl bg-black text-white grid
place-items-center font-bold">LE</div>
           <h1 className="text-xl font-semibold
tracking-tight">Leveraged Single-Stock ETF Catalog</h1>
           <div className="ml-auto flex items-center gap-2">
             <input
               value={q}
               onChange={(e) => setQ(e.target.value)}
               placeholder="Search ticker, name, issuer, underlying…"
               className="hidden md:block w-80 rounded-xl border
border-zinc-300 bg-white px-3 py-2 text-sm"
             />
             <label className="relative inline-flex items-center px-3
py-2 rounded-xl border text-sm cursor-pointer">
               <input type="file" accept="application/json"
onChange={handleUpload} className="absolute inset-0 opacity-0
cursor-pointer" />
               Upload JSON
             </label>
           </div>
         </div>
       </header>

       <main className="mx-auto max-w-7xl px-4 py-6 grid gap-6">
         {/* Filters card */}
         <div className="rounded-2xl border bg-white p-4 shadow-sm">
           <div className="flex flex-wrap items-center gap-3">
             <div className="flex items-center gap-2">
               <span className="text-xs font-medium
text-zinc-500">Leverage</span>
               <div className="flex items-center gap-2">
                 <span className="inline-flex h-7 min-w-10 items-center
justify-center rounded-xl bg-zinc-100 px-2 text-xs
font-medium">{minSigned}x</span>
                 <input type="range" min={sliderMin} max={sliderMax}
step={0.5} value={minSigned}
onChange={(e)=>setMinSigned(Number(e.target.value))} />
                 <input type="range" min={sliderMin} max={sliderMax}
step={0.5} value={maxSigned}
onChange={(e)=>setMaxSigned(Number(e.target.value))} />
                 <span className="inline-flex h-7 min-w-10 items-center
justify-center rounded-xl bg-zinc-100 px-2 text-xs
font-medium">{maxSigned}x</span>
               </div>
             </div>

             <div className="flex items-center gap-2">
               <span className="text-xs font-medium
text-zinc-500">Direction</span>
               <select value={direction}
onChange={(e)=>setDirection(e.target.value as any)}
className="rounded-xl border border-zinc-300 bg-white px-2 py-1 text-sm">
                 <option value="ALL">All</option>
                 <option value="Long">Long</option>
                 <option value="Inverse">Inverse</option>
               </select>
             </div>

             <div className="flex items-center gap-2">
               <span className="text-xs font-medium
text-zinc-500">Issuer</span>
               <select value={issuer}
onChange={(e)=>setIssuer(e.target.value)} className="rounded-xl border
border-zinc-300 bg-white px-2 py-1 text-sm">
                 {issuers.map((ix)=> (<option key={ix}
value={ix}>{ix}</option>))}
               </select>
             </div>

             <div className="flex items-center gap-2">
               <span className="text-xs font-medium
text-zinc-500">Underlying</span>
               <select value={underlying}
onChange={(e)=>setUnderlying(e.target.value)} className="rounded-xl
border border-zinc-300 bg-white px-2 py-1 text-sm">
                 {underlyings.map((u)=> (<option key={u}
value={u}>{u}</option>))}
               </select>
             </div>

             <div className="ml-auto md:hidden w-full">
               <input
                 value={q}
                 onChange={(e) => setQ(e.target.value)}
                 placeholder="Search ticker, name, issuer, underlying…"
                 className="w-full rounded-xl border border-zinc-300
bg-white px-3 py-2 text-sm"
               />
             </div>
           </div>
         </div>

         {/* Table */}
         <div className="rounded-2xl border bg-white shadow-sm
overflow-hidden">
           <table className="min-w-full text-sm">
             <thead className="bg-zinc-50 sticky top-[57px] z-10">
               <tr className="text-zinc-600">
                 {(
                   [
                     {k:"#", w:"w-10"},
                     {k:"Ticker", s:"ticker"},
                     {k:"Name", s:"name", w:"min-w-[22rem]"},
                     {k:"Issuer", s:"issuer"},
                     {k:"Underlying", s:"underlying"},
                     {k:"Assets (M)", s:"assets", al:"right"},
                     {k:"Fee %", s:"fee", al:"right"},
                     {k:"Lev (±)", s:"lev", al:"right"},
                     {k:"Dir", s:"dir"},
                     {k:"Type"},
                     {k:"Link"}
                   ] as const
                 ).map((col, idx) => (
                   <th key={idx} className={`p-3 text-xs font-semibold
${col.al === 'right' ? 'text-right' : 'text-left'} ${col.w ?? ''}`}>
                     <button
                       disabled={!("s" in col)}
                       onClick={() => {
                         // @ts-ignore - s may not exist on some columns
                         const key = (col as any).s as string | undefined;
                         if (!key) return;
                         setSortKey(key);
                         setSortDir((d) => (sortKey === key ? (d ===
'asc' ? 'desc' : 'asc') : 'desc'));
                       }}
                       className={`inline-flex items-center gap-1 ${"s"
in col ? 'hover:underline' : ''}`}
                     >
                       {col.k}
                       {"s" in col && sortKey === (col as any).s && (
                         <span className="text-zinc-400">{sortDir ===
'asc' ? '▲' : '▼'}</span>
                       )}
                     </button>
                   </th>
                 ))}
               </tr>
             </thead>
             <tbody>
               {filtered.map((row, i) => (
                 <tr key={i} className="border-t hover:bg-zinc-50
transition-colors">
                   <td className="p-3 text-zinc-500">{i + 1}</td>
                   <td className="p-3 font-mono
font-semibold">{row["Ticker"]}</td>
                   <td className="p-3">
                     <div className="font-medium">{row["Name"]}</div>
                     <div className="text-xs
text-zinc-500">{row["symbol"] ?? row["CUSIP"] ?? ""}</div>
                   </td>
                   <td className="p-3">{row.issuerDetected}</td>
                   <td className="p-3">{row.underlyingDetected}</td>
                   <td className="p-3 text-right
tabular-nums">{row["Fund Assets (M USD)"]?.toLocaleString()}</td>
                   <td className="p-3 text-right
tabular-nums">{row["Expense Ratio"]}</td>
                   <td className="p-3 text-right">
                     {row.signedLev == null ? (
                       <span className="text-zinc-400">—</span>
                     ) : (
                       <span className={`inline-flex items-center
justify-center rounded-full px-2 h-6 text-xs font-semibold tabular-nums
${row.signedLev > 0 ? 'bg-emerald-100 text-emerald-700' : 'bg-rose-100
text-rose-700'}`}>
                         {row.signedLev > 0 ? `+${row.signedLev}x` :
`${row.signedLev}x`}
                       </span>
                     )}
                   </td>
                   <td className="p-3">{row.direction ?? "—"}</td>
                   <td className="p-3">{row["Fund Type"]}</td>
                   <td className="p-3">
                     {row.url ? (
                       <a className="inline-flex items-center gap-1
text-blue-600 hover:underline" href={row.url} target="_blank"
rel="noreferrer">
                         Prospectus <span aria-hidden>↗</span>
                       </a>
                     ) : (
                       <span className="text-zinc-400">—</span>
                     )}
                   </td>
                 </tr>
               ))}
             </tbody>
           </table>
         </div>
       </main>
     </div>
   );
}
